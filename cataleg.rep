// Hem escollit la taula de dispersió perquè compleix molt bé respecte a altres opcions per implementar aquesta classe.
// La taula de dispersió generalment garanteix en les operacions d'inserir, consultar i eliminar costs constants. Per tant, son molt bons costos.
// Des d'un principi ha sigut la primera opció d'implementació en la qual vam pensar i creiem que es la millor opció que hi ha d'implementar aquesta classe de totes les que hem estudiat.
// Hem decidit implementar la versió amb sinònims encadenats per evitar la degeneració amb insercions i eliminacions.

struct node
{
    nat _k; 			//clau
    phone _v; 			//valor
    node* _seg;	// Node seguent
    node(const nat &k, const phone &v, node* seg = NULL);		// Constructor de node
};

node ** _taula;
nat _M;
nat _quants;

// Després de realitzar una cerca exhaustiva i de provar moltes funcions, hem escollit aquesta funció de
// dispersió, ja que proporciona una distribució estadística molt bona. Cada bit d’entrada afecta
// cada bit de sortida amb com a molt un 50% de probabilitat.
// El nombre màgic es va calcular mitjançant un programa especial de proves que va funcionar durant
// moltes hores, que calcula l'efecte anomenat "allau".
// L'autor d'aquesta funció és Evgenij Ryazanov.
// Aquesta funció de dispersió compleix amb els requisits que es demanen per a una bona funció de hash:
//	● Distribució uniforme
//	● Independència de l'aparença de la clau
//	● Exhaustivitat
//	● Rapidesa de càlcul
int hash(const nat &c) const throw()
{
	int x = c;
    x = ((x >> 16) ^ x) * 0x119de1f3; // Cambiar
    x = ((x >> 16) ^ x) * 0x119de1f3;
    x = (x >> 16) ^ x;
    return x;
}

// Borra tots els encadenaments.
static void esborra_nodes(node **taula, nat size); // Cost lineal respecte a _M

// Funcio que retorna el node corresponent al numero num.
node* pos(nat num) const;  //cost constant

// Copia tots els nodes d'una llista.
static node* copia_nodes(node* m); // Cost lineal respecte a _M

// Funcio per intercambiar objectes per al operador ==.
void swap_taula(call_registry &R);

// Funcio que redispersiona la taula.
void redispersio(); // Cost lineal respecte a _M
